
importFromModule("formats", "Formats");
importFromModule("config.environments.development.development", "config");

importModule('helma.skin');
importModule('templating.este', 'este');
importModule('templating.ejs', 'ejs');

/**
 * Writes content to the response.
 * 
 * <p>Depending on the options you pass to the function it will do the following
 *
 * <dl> 
 * <dt>render()</dt><dd>
 *  With no parameter, the render method renders the default template 
 *  for the current controller and action. The following code will render the 
 *  template <span class=path>app/views/blog/index.skin</span>
 *  <pre class=javascript>
 * importModule(“aida.controller”, “Controller”);
 * this.__proto__ = Controller;
 * 
 * function index() {
 * 	render();
 * }
 *  </pre>
 *
 *  <p>render() may just be called once per request. If you don't call render() in your
 *  action method, Controller, or to be more specific - handleRequest, will
 *  perform it without any parameters.
 *  <p>If you don't specify a handler method for the action, Action Controller will try
 *  to find the corresponding template (skin) and call it. If it can't find a method nor 
 *  a template for the matching route (controller/action) it will call the action "notfound"
 *  for the controller.
 * </dd> 
 * 
 * <dt>render({text:<string>})</dt><dd>
 *  <p>Sends the given string to the response. 
 *  No template interpretation or HTML escaping is performed.
 *  <pre class=javascript>
 * function index_action() {
 *	    render({text: "Hello there!"});
 * }
 *  </pre>
 * </dd>
 *
 * <dt>render({template:<string>, type:<skin|extension>, context:<object>})</dt><dd>
 *  <p>Interprets string as the source to a template of the given type, rendering the 
 *  results back to the client. If the :locals hash is given, the contents are used 
 *  to set the values of local variables in the template. 
 *  <p>The following code adds method_missing to a controller if the application is 
 *  running in development mode. If the controller is called with an invalid action, 
 *  this renders an inline template to display the action’s name and a formatted version 
 *  of the request parameters.
 *  <code class=javascript>
 * function welcome_action() {
 *	  render({
 *     template: 
 *       '&lt;h2&gt;Hello &lt;% name %>!&lt;/h2&gt; \
 *        &lt;p&gt;Welcome, and have a nice day!&lt;/p&gt;',
 *     context : { name : "Matthias" }
 *   });
 * }
 *  </code> 
 *  <p>Note: You have to end each line of the multi line string with a backslash,
 *  otherwise you will get an “unterminated string literal” error from Rhino.
 * </dd>
 *
 * <dt>render({action:<string>})</dt><dd>
 *  <p>Renders the template for a given action in this controller.
 *  <pre class=javascript>
 * function display_cart_action() {
 *	  if (cart.isEmpty()) { 
 *     render({action:"index"});
 *   } else {
 *     // ...
 *   }
 * }
 *  </pre>
 *  Note that calling render({action:...}) does not call the action method; 
 *  it simply displays the template. If the template needs instance variables, 
 *  these must be set up by the method that calls the render.
 * </dd>
 * </dl>
 * 
 * @param {object} options Options for defining the output. See description.
 */
function render(options) {
   if (!res.contentType) res.contentType = Formats.getMimeType(req.route.format);
   if (!options) options = {};
   if (res.calledRender) throw new DoubleRenderError();
   res.calledRender = true;
   var action = options.action || req.route.action;
   var context = controller.prepareContext(options.context);
   if (options.layout !== undefined) controller.setLayout(options.layout);
   
   delete options.layout;
   
   if (typeof options === "string" && options !== "") {
      res.writeln(options);
   } else if (options && options.inline) {
      var options = Object.extend({
         type : "skin",
         locals : {}
      }, options);
      if (options.type === "skin") {
         /*
         var skin = [];
         helma.skin.parseSkin(options.inline, function(part) {
            skin.push(part);
         });
         FIXME: can't create inline skin on the fly
         */
         var skin = new helma.skin.Skin(options.inline);
         skin.render(options.locals);
      }
   } else {
      // FIXME: template types should be moved to modules using a plugin/interface mechansim
      var type = this.determineTemplateType({action:action, format:req.route.format});
      if (type === "est") {
         var resource = this.getTemplateSource({action:action, type:type});
         new este.TemplateEngine(resource.getContent()).evaluate(res, context);
      } else if (type === "ejs") {
         var resource = this.getTemplateSource({action:action, type:type});
         var result = new ejs.EJS(resource.getContent()).render(context);
         res.write(result);
      } else if (type === "skin") {
         helma.skin.render(this.getTemplatePath({action:action, type:type}), context);
      } else if (type) {
         helma.skin.render(this.getTemplatePath({action:action, type:type}), context);
      } else {
         res.writeln("Couldn't find " + this.getTemplateSource({action:action, type:type || "skin"}));
      }
   }
}

function prepareContext(context) {
   var result = {};
   for (var name in this.helpers) {
      if (this.helpers[name]._namespace) {
         result[this.helpers[name]._namespace] = this.helpers[name];
      } else {
         result = Object.extend(result, this.helpers[name]);         
      }
   }
   result = Object.extend(
      result,
      {
         request : req.data,
         controller : controller,
         flash : req.flash,
         headers : req.headers, 
         logger : logger, 
         params : req.data, 
         request : req, 
         response : res,
         session : session   
      },
      this.context || {}
   );
   result = Object.extend(result, context || {});
   return result;
}

function determineTemplateType(options) {
   var types = ["est", "ejs", "skin", options.format];
   for (var i=0; i<types.length; i++) {
      if (this.getTemplateSource(Object.extend(options, {type:types[i]})).exists()) {
         return types[i];
      }
   }
   return;
}

function getTemplateSource(options) {
   return this.getResource(this.getTemplatePath(options));
}

function getTemplatePath(options) {
   logger.info(uneval(options))
   var options = Object.extend({
      action : "index",
      controller : this.getShortName(),
      format : "html",
      type : "skin"
   }, options || {});
   var result = (config.templateRoot || "app/views") + '/' + options.controller + '/' + options.action + '.' + options.format + ((options.type != options.format) ? ('.' + options.type) : '');
   return result;
}
